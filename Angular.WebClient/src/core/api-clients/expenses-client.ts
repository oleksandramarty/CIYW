//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL_Expenses = new InjectionToken<string>('API_BASE_URL_Expenses');

@Injectable()
export class ExpenseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL_Expenses) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    expense_CreateOrUpdateExpense(request: CreateOrUpdateExpenseCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/expenses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExpense_CreateOrUpdateExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExpense_CreateOrUpdateExpense(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExpense_CreateOrUpdateExpense(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    expense_RemoveExpense(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/expenses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExpense_RemoveExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExpense_RemoveExpense(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processExpense_RemoveExpense(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    expense_GetFilteredExpenses(request: GetFilteredExpensesRequest): Observable<ListWithIncludeResponseOfExpenseResponse> {
        let url_ = this.baseUrl + "/api/v1/expenses/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExpense_GetFilteredExpenses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExpense_GetFilteredExpenses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListWithIncludeResponseOfExpenseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListWithIncludeResponseOfExpenseResponse>;
        }));
    }

    protected processExpense_GetFilteredExpenses(response: HttpResponseBase): Observable<ListWithIncludeResponseOfExpenseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListWithIncludeResponseOfExpenseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    plannedExpense_CreateOrUpdatePlannedExpense(request: CreateOrUpdatePlannedExpenseCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/planned-expenses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlannedExpense_CreateOrUpdatePlannedExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlannedExpense_CreateOrUpdatePlannedExpense(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPlannedExpense_CreateOrUpdatePlannedExpense(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    plannedExpense_RemovePlannedExpense(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/planned-expenses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlannedExpense_RemovePlannedExpense(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlannedExpense_RemovePlannedExpense(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processPlannedExpense_RemovePlannedExpense(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    plannedExpense_GetFilteredPlannedExpenses(request: GetFilteredPlannedExpensesRequest): Observable<ListWithIncludeResponseOfPlannedExpenseResponse> {
        let url_ = this.baseUrl + "/api/v1/planned-expenses/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPlannedExpense_GetFilteredPlannedExpenses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPlannedExpense_GetFilteredPlannedExpenses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListWithIncludeResponseOfPlannedExpenseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListWithIncludeResponseOfPlannedExpenseResponse>;
        }));
    }

    protected processPlannedExpense_GetFilteredPlannedExpenses(response: HttpResponseBase): Observable<ListWithIncludeResponseOfPlannedExpenseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListWithIncludeResponseOfPlannedExpenseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userProject_GetAllowedProjects(): Observable<UserAllowedProjectResponse[]> {
        let url_ = this.baseUrl + "/api/v1/user-projects/allowed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProject_GetAllowedProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProject_GetAllowedProjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserAllowedProjectResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserAllowedProjectResponse[]>;
        }));
    }

    protected processUserProject_GetAllowedProjects(response: HttpResponseBase): Observable<UserAllowedProjectResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserAllowedProjectResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userProject_GetProjects(): Observable<UserProjectResponse[]> {
        let url_ = this.baseUrl + "/api/v1/user-projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProject_GetProjects(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProject_GetProjects(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProjectResponse[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProjectResponse[]>;
        }));
    }

    protected processUserProject_GetProjects(response: HttpResponseBase): Observable<UserProjectResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserProjectResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userProject_AddProject(request: CreateUserProjectCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/user-projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProject_AddProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProject_AddProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserProject_AddProject(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userProject_GetUserProject(id: string): Observable<UserProjectResponse> {
        let url_ = this.baseUrl + "/api/v1/user-projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserProject_GetUserProject(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserProject_GetUserProject(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProjectResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProjectResponse>;
        }));
    }

    protected processUserProject_GetUserProject(response: HttpResponseBase): Observable<UserProjectResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorMessageModel.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ErrorMessageModel.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ErrorMessageModel.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ErrorMessageModel.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ErrorMessageModel.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status === 417) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result417: any = null;
            let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result417 = ErrorMessageModel.fromJS(resultData417);
            return throwException("A server side error occurred.", status, _responseText, _headers, result417);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorMessageModel.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProjectResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ErrorMessageModel implements IErrorMessageModel {
    invalidFields!: InvalidFieldInfoModel[];
    message!: string;
    statusCode!: number;

    constructor(data?: IErrorMessageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.invalidFields = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["invalidFields"])) {
                this.invalidFields = [] as any;
                for (let item of _data["invalidFields"])
                    this.invalidFields!.push(InvalidFieldInfoModel.fromJS(item));
            }
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): ErrorMessageModel {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorMessageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.invalidFields)) {
            data["invalidFields"] = [];
            for (let item of this.invalidFields)
                data["invalidFields"].push(item.toJSON());
        }
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        return data;
    }
}

export interface IErrorMessageModel {
    invalidFields: InvalidFieldInfoModel[];
    message: string;
    statusCode: number;
}

export class InvalidFieldInfoModel implements IInvalidFieldInfoModel {
    propertyName!: string;
    code!: string;
    errorMessage!: string;

    constructor(data?: IInvalidFieldInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.code = _data["code"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): InvalidFieldInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new InvalidFieldInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["code"] = this.code;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IInvalidFieldInfoModel {
    propertyName: string;
    code: string;
    errorMessage: string;
}

export class CreateOrUpdateExpenseCommand implements ICreateOrUpdateExpenseCommand {
    id?: string | undefined;
    title!: string;
    description?: string | undefined;
    amount!: number;
    date!: Date;
    categoryId!: number;
    userProjectId!: string;
    balanceId!: string;

    constructor(data?: ICreateOrUpdateExpenseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.userProjectId = _data["userProjectId"];
            this.balanceId = _data["balanceId"];
        }
    }

    static fromJS(data: any): CreateOrUpdateExpenseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateExpenseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["userProjectId"] = this.userProjectId;
        data["balanceId"] = this.balanceId;
        return data;
    }
}

export interface ICreateOrUpdateExpenseCommand {
    id?: string | undefined;
    title: string;
    description?: string | undefined;
    amount: number;
    date: Date;
    categoryId: number;
    userProjectId: string;
    balanceId: string;
}

export class ListWithIncludeResponseOfExpenseResponse implements IListWithIncludeResponseOfExpenseResponse {
    entities!: ExpenseResponse[];
    paginator?: PaginatorEntity | undefined;
    totalCount!: number;
    totalCountWithoutFilter!: number;

    constructor(data?: IListWithIncludeResponseOfExpenseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entities"])) {
                this.entities = [] as any;
                for (let item of _data["entities"])
                    this.entities!.push(ExpenseResponse.fromJS(item));
            }
            this.paginator = _data["paginator"] ? PaginatorEntity.fromJS(_data["paginator"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.totalCountWithoutFilter = _data["totalCountWithoutFilter"];
        }
    }

    static fromJS(data: any): ListWithIncludeResponseOfExpenseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListWithIncludeResponseOfExpenseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entities)) {
            data["entities"] = [];
            for (let item of this.entities)
                data["entities"].push(item.toJSON());
        }
        data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalCountWithoutFilter"] = this.totalCountWithoutFilter;
        return data;
    }
}

export interface IListWithIncludeResponseOfExpenseResponse {
    entities: ExpenseResponse[];
    paginator?: PaginatorEntity | undefined;
    totalCount: number;
    totalCountWithoutFilter: number;
}

export class BaseIdEntityOfGuid implements IBaseIdEntityOfGuid {
    id!: string;

    constructor(data?: IBaseIdEntityOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseIdEntityOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new BaseIdEntityOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IBaseIdEntityOfGuid {
    id: string;
}

export class BaseDateTimeEntityOfGuid extends BaseIdEntityOfGuid implements IBaseDateTimeEntityOfGuid {
    created!: Date;
    modified?: Date | undefined;

    constructor(data?: IBaseDateTimeEntityOfGuid) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.modified = _data["modified"] ? new Date(_data["modified"].toString()) : <any>undefined;
        }
    }

    static override fromJS(data: any): BaseDateTimeEntityOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDateTimeEntityOfGuid();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["modified"] = this.modified ? this.modified.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseDateTimeEntityOfGuid extends IBaseIdEntityOfGuid {
    created: Date;
    modified?: Date | undefined;
}

export class ExpenseResponse extends BaseDateTimeEntityOfGuid implements IExpenseResponse {
    title!: string;
    description?: string | undefined;
    amount!: number;
    balanceId!: string;
    date!: Date;
    categoryId!: number;
    isIncome!: boolean;
    userProjectId!: string;
    createdUserId!: string;
    version!: string;

    constructor(data?: IExpenseResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.balanceId = _data["balanceId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.isIncome = _data["isIncome"];
            this.userProjectId = _data["userProjectId"];
            this.createdUserId = _data["createdUserId"];
            this.version = _data["version"];
        }
    }

    static override fromJS(data: any): ExpenseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["balanceId"] = this.balanceId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["isIncome"] = this.isIncome;
        data["userProjectId"] = this.userProjectId;
        data["createdUserId"] = this.createdUserId;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface IExpenseResponse extends IBaseDateTimeEntityOfGuid {
    title: string;
    description?: string | undefined;
    amount: number;
    balanceId: string;
    date: Date;
    categoryId: number;
    isIncome: boolean;
    userProjectId: string;
    createdUserId: string;
    version: string;
}

export class PaginatorEntity implements IPaginatorEntity {
    pageNumber!: number;
    pageSize!: number;
    isFull!: boolean;

    constructor(data?: IPaginatorEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.isFull = _data["isFull"];
        }
    }

    static fromJS(data: any): PaginatorEntity {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatorEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["isFull"] = this.isFull;
        return data;
    }
}

export interface IPaginatorEntity {
    pageNumber: number;
    pageSize: number;
    isFull: boolean;
}

export class BaseFilterRequest implements IBaseFilterRequest {
    paginator?: PaginatorEntity | undefined;
    sort?: BaseSortableRequest | undefined;
    dateRange?: BaseDateRangeFilterRequest | undefined;
    amountRange?: BaseAmountRangeFilterRequest | undefined;
    query?: string | undefined;

    constructor(data?: IBaseFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paginator = _data["paginator"] ? PaginatorEntity.fromJS(_data["paginator"]) : <any>undefined;
            this.sort = _data["sort"] ? BaseSortableRequest.fromJS(_data["sort"]) : <any>undefined;
            this.dateRange = _data["dateRange"] ? BaseDateRangeFilterRequest.fromJS(_data["dateRange"]) : <any>undefined;
            this.amountRange = _data["amountRange"] ? BaseAmountRangeFilterRequest.fromJS(_data["amountRange"]) : <any>undefined;
            this.query = _data["query"];
        }
    }

    static fromJS(data: any): BaseFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BaseFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
        data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
        data["dateRange"] = this.dateRange ? this.dateRange.toJSON() : <any>undefined;
        data["amountRange"] = this.amountRange ? this.amountRange.toJSON() : <any>undefined;
        data["query"] = this.query;
        return data;
    }
}

export interface IBaseFilterRequest {
    paginator?: PaginatorEntity | undefined;
    sort?: BaseSortableRequest | undefined;
    dateRange?: BaseDateRangeFilterRequest | undefined;
    amountRange?: BaseAmountRangeFilterRequest | undefined;
    query?: string | undefined;
}

export class GetFilteredExpensesRequest extends BaseFilterRequest implements IGetFilteredExpensesRequest {
    userProjectId!: string;
    categoryIds!: number[];

    constructor(data?: IGetFilteredExpensesRequest) {
        super(data);
        if (!data) {
            this.categoryIds = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userProjectId = _data["userProjectId"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): GetFilteredExpensesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetFilteredExpensesRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userProjectId"] = this.userProjectId;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGetFilteredExpensesRequest extends IBaseFilterRequest {
    userProjectId: string;
    categoryIds: number[];
}

export class BaseSortableRequest implements IBaseSortableRequest {
    column!: string;
    direction!: string;

    constructor(data?: IBaseSortableRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): BaseSortableRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BaseSortableRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        data["direction"] = this.direction;
        return data;
    }
}

export interface IBaseSortableRequest {
    column: string;
    direction: string;
}

export class BaseDateRangeFilterRequest implements IBaseDateRangeFilterRequest {
    startDate?: Date | undefined;
    endDate?: Date | undefined;

    constructor(data?: IBaseDateRangeFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseDateRangeFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BaseDateRangeFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBaseDateRangeFilterRequest {
    startDate?: Date | undefined;
    endDate?: Date | undefined;
}

export class BaseAmountRangeFilterRequest implements IBaseAmountRangeFilterRequest {
    amountFrom?: number | undefined;
    amountTo?: number | undefined;

    constructor(data?: IBaseAmountRangeFilterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
        }
    }

    static fromJS(data: any): BaseAmountRangeFilterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BaseAmountRangeFilterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        return data;
    }
}

export interface IBaseAmountRangeFilterRequest {
    amountFrom?: number | undefined;
    amountTo?: number | undefined;
}

export class CreateOrUpdatePlannedExpenseCommand implements ICreateOrUpdatePlannedExpenseCommand {
    id?: string | undefined;
    title!: string;
    description?: string | undefined;
    amount!: number;
    categoryId!: number;
    balanceId!: string;
    startDate!: Date;
    endDate?: Date | undefined;
    userProjectId!: string;
    frequencyId!: number;
    isActive!: boolean;

    constructor(data?: ICreateOrUpdatePlannedExpenseCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.categoryId = _data["categoryId"];
            this.balanceId = _data["balanceId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.userProjectId = _data["userProjectId"];
            this.frequencyId = _data["frequencyId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrUpdatePlannedExpenseCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePlannedExpenseCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["categoryId"] = this.categoryId;
        data["balanceId"] = this.balanceId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["userProjectId"] = this.userProjectId;
        data["frequencyId"] = this.frequencyId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateOrUpdatePlannedExpenseCommand {
    id?: string | undefined;
    title: string;
    description?: string | undefined;
    amount: number;
    categoryId: number;
    balanceId: string;
    startDate: Date;
    endDate?: Date | undefined;
    userProjectId: string;
    frequencyId: number;
    isActive: boolean;
}

export class ListWithIncludeResponseOfPlannedExpenseResponse implements IListWithIncludeResponseOfPlannedExpenseResponse {
    entities!: PlannedExpenseResponse[];
    paginator?: PaginatorEntity | undefined;
    totalCount!: number;
    totalCountWithoutFilter!: number;

    constructor(data?: IListWithIncludeResponseOfPlannedExpenseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.entities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entities"])) {
                this.entities = [] as any;
                for (let item of _data["entities"])
                    this.entities!.push(PlannedExpenseResponse.fromJS(item));
            }
            this.paginator = _data["paginator"] ? PaginatorEntity.fromJS(_data["paginator"]) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.totalCountWithoutFilter = _data["totalCountWithoutFilter"];
        }
    }

    static fromJS(data: any): ListWithIncludeResponseOfPlannedExpenseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListWithIncludeResponseOfPlannedExpenseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entities)) {
            data["entities"] = [];
            for (let item of this.entities)
                data["entities"].push(item.toJSON());
        }
        data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["totalCountWithoutFilter"] = this.totalCountWithoutFilter;
        return data;
    }
}

export interface IListWithIncludeResponseOfPlannedExpenseResponse {
    entities: PlannedExpenseResponse[];
    paginator?: PaginatorEntity | undefined;
    totalCount: number;
    totalCountWithoutFilter: number;
}

export class PlannedExpenseResponse extends BaseDateTimeEntityOfGuid implements IPlannedExpenseResponse {
    title!: string;
    description?: string | undefined;
    amount!: number;
    categoryId!: number;
    balanceId!: string;
    startDate!: Date;
    endDate?: Date | undefined;
    userId!: string;
    userProjectId!: string;
    frequencyId!: number;
    isActive!: boolean;
    version!: string;

    constructor(data?: IPlannedExpenseResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.categoryId = _data["categoryId"];
            this.balanceId = _data["balanceId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.userProjectId = _data["userProjectId"];
            this.frequencyId = _data["frequencyId"];
            this.isActive = _data["isActive"];
            this.version = _data["version"];
        }
    }

    static override fromJS(data: any): PlannedExpenseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PlannedExpenseResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["categoryId"] = this.categoryId;
        data["balanceId"] = this.balanceId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["userProjectId"] = this.userProjectId;
        data["frequencyId"] = this.frequencyId;
        data["isActive"] = this.isActive;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface IPlannedExpenseResponse extends IBaseDateTimeEntityOfGuid {
    title: string;
    description?: string | undefined;
    amount: number;
    categoryId: number;
    balanceId: string;
    startDate: Date;
    endDate?: Date | undefined;
    userId: string;
    userProjectId: string;
    frequencyId: number;
    isActive: boolean;
    version: string;
}

export class GetFilteredPlannedExpensesRequest extends BaseFilterRequest implements IGetFilteredPlannedExpensesRequest {
    userProjectId!: string;
    categoryIds!: number[];

    constructor(data?: IGetFilteredPlannedExpensesRequest) {
        super(data);
        if (!data) {
            this.categoryIds = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userProjectId = _data["userProjectId"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
        }
    }

    static override fromJS(data: any): GetFilteredPlannedExpensesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetFilteredPlannedExpensesRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userProjectId"] = this.userProjectId;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IGetFilteredPlannedExpensesRequest extends IBaseFilterRequest {
    userProjectId: string;
    categoryIds: number[];
}

export class UserAllowedProjectResponse extends BaseIdEntityOfGuid implements IUserAllowedProjectResponse {
    userProjectId!: string;
    userProject!: UserProjectResponse;
    userId!: string;
    isReadOnly!: boolean;

    constructor(data?: IUserAllowedProjectResponse) {
        super(data);
        if (!data) {
            this.userProject = new UserProjectResponse();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userProjectId = _data["userProjectId"];
            this.userProject = _data["userProject"] ? UserProjectResponse.fromJS(_data["userProject"]) : new UserProjectResponse();
            this.userId = _data["userId"];
            this.isReadOnly = _data["isReadOnly"];
        }
    }

    static override fromJS(data: any): UserAllowedProjectResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserAllowedProjectResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userProjectId"] = this.userProjectId;
        data["userProject"] = this.userProject ? this.userProject.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["isReadOnly"] = this.isReadOnly;
        super.toJSON(data);
        return data;
    }
}

export interface IUserAllowedProjectResponse extends IBaseIdEntityOfGuid {
    userProjectId: string;
    userProject: UserProjectResponse;
    userId: string;
    isReadOnly: boolean;
}

export class UserProjectResponse extends BaseDateTimeEntityOfGuid implements IUserProjectResponse {
    title!: string;
    isActive!: boolean;
    createdUserId!: string;
    balances!: BalanceResponse[];
    version!: string;

    constructor(data?: IUserProjectResponse) {
        super(data);
        if (!data) {
            this.balances = [];
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.isActive = _data["isActive"];
            this.createdUserId = _data["createdUserId"];
            if (Array.isArray(_data["balances"])) {
                this.balances = [] as any;
                for (let item of _data["balances"])
                    this.balances!.push(BalanceResponse.fromJS(item));
            }
            this.version = _data["version"];
        }
    }

    static override fromJS(data: any): UserProjectResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserProjectResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["isActive"] = this.isActive;
        data["createdUserId"] = this.createdUserId;
        if (Array.isArray(this.balances)) {
            data["balances"] = [];
            for (let item of this.balances)
                data["balances"].push(item.toJSON());
        }
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface IUserProjectResponse extends IBaseDateTimeEntityOfGuid {
    title: string;
    isActive: boolean;
    createdUserId: string;
    balances: BalanceResponse[];
    version: string;
}

export class BalanceResponse extends BaseDateTimeEntityOfGuid implements IBalanceResponse {
    userId!: string;
    amount!: number;
    currencyId!: number;
    userProjectId!: string;
    version!: string;

    constructor(data?: IBalanceResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.amount = _data["amount"];
            this.currencyId = _data["currencyId"];
            this.userProjectId = _data["userProjectId"];
            this.version = _data["version"];
        }
    }

    static override fromJS(data: any): BalanceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["amount"] = this.amount;
        data["currencyId"] = this.currencyId;
        data["userProjectId"] = this.userProjectId;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface IBalanceResponse extends IBaseDateTimeEntityOfGuid {
    userId: string;
    amount: number;
    currencyId: number;
    userProjectId: string;
    version: string;
}

export class CreateUserProjectCommand implements ICreateUserProjectCommand {
    title!: string;
    isActive!: boolean;
    currencyIds!: number[];

    constructor(data?: ICreateUserProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currencyIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["currencyIds"])) {
                this.currencyIds = [] as any;
                for (let item of _data["currencyIds"])
                    this.currencyIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.currencyIds)) {
            data["currencyIds"] = [];
            for (let item of this.currencyIds)
                data["currencyIds"].push(item);
        }
        return data;
    }
}

export interface ICreateUserProjectCommand {
    title: string;
    isActive: boolean;
    currencyIds: number[];
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}